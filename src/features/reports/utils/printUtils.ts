import type { RefObject } from 'react';
import type { ReportPeriodType } from '@/types/report';
import { TRANSLATIONS, type Language } from '@/utils/translations';

/** Month abbreviations for PDF filename (Spanish by design — brand consistency in filenames) */
const MONTH_ABBR = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];

/**
 * Generates a filename for the PDF export based on period type and date range.
 * Examples:
 * - Weekly: Gastify_report_2025_Q4_Dic_S52
 * - Monthly: Gastify_report_2025_Q4_Dic
 * - Quarterly: Gastify_report_2025_Q4
 * - Yearly: Gastify_report_2025
 */
export const generatePdfFilename = (
  periodType: ReportPeriodType,
  dateRange: { start: Date; end: Date }
): string => {
  const year = dateRange.start.getFullYear();
  const month = dateRange.start.getMonth(); // 0-indexed
  const quarter = Math.floor(month / 3) + 1;
  const monthAbbr = MONTH_ABBR[month];

  // Calculate week number (ISO week)
  const startOfYear = new Date(year, 0, 1);
  const days = Math.floor((dateRange.start.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000));
  const weekNum = Math.ceil((days + startOfYear.getDay() + 1) / 7);

  switch (periodType) {
    case 'weekly':
      return `Gastify_report_${year}_Q${quarter}_${monthAbbr}_S${weekNum}`;
    case 'monthly':
      return `Gastify_report_${year}_Q${quarter}_${monthAbbr}`;
    case 'quarterly':
      return `Gastify_report_${year}_Q${quarter}`;
    case 'yearly':
      return `Gastify_report_${year}`;
    default:
      return `Gastify_report_${year}`;
  }
};

/**
 * Handles PDF export by cloning report content to a print container.
 * Uses DOM APIs (createElement/textContent) instead of innerHTML to prevent
 * XSS even if upstream report data were compromised (defense-in-depth).
 */
export const handlePrintReport = (
  reportContentRef: RefObject<HTMLDivElement | null>,
  reportData: {
    fullTitle: string;
    transactionCount: number;
    periodType: ReportPeriodType;
    dateRange: { start: Date; end: Date };
  },
  lang: Language = 'es'
) => {
  const reportContent = reportContentRef.current;
  if (!reportContent) return;

  const t = TRANSLATIONS[lang] || TRANSLATIONS.en;
  const locale = lang === 'es' ? 'es-CL' : 'en-US';

  // Generate filename and set document title (Chrome uses title as default PDF name)
  const filename = generatePdfFilename(reportData.periodType, reportData.dateRange);
  const originalTitle = document.title;
  document.title = filename;

  // Create or get print container
  let printContainer = document.getElementById('print-container');
  if (!printContainer) {
    printContainer = document.createElement('div');
    printContainer.id = 'print-container';
    document.body.appendChild(printContainer);
  }

  // Clone the report content
  const clone = reportContent.cloneNode(true) as HTMLElement;

  // Build branding header using DOM APIs (matches TopHeader wordmark styling)
  const brandingEl = document.createElement('div');
  brandingEl.className = 'print-branding';
  const logoCircle = document.createElement('div');
  logoCircle.className = 'print-logo-circle';
  logoCircle.textContent = 'G';
  const wordmark = document.createElement('span');
  wordmark.className = 'print-wordmark';
  wordmark.textContent = 'Gastify';
  brandingEl.append(logoCircle, wordmark);

  // Build report header using DOM APIs (textContent for user data — XSS-safe)
  const headerEl = document.createElement('div');
  headerEl.className = 'print-report-header';
  const h1 = document.createElement('h1');
  h1.textContent = reportData.fullTitle;
  const headerP = document.createElement('p');
  const txLabel = reportData.transactionCount === 1 ? t.transactionSingular : t.transactionPlural;
  headerP.textContent = `${reportData.transactionCount} ${txLabel}`;
  headerEl.append(h1, headerP);

  // Build footer using DOM APIs
  const now = new Date();
  const dateStr = now.toLocaleDateString(locale, {
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });
  const timeStr = now.toLocaleTimeString(locale, {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  });
  const footerEl = document.createElement('div');
  footerEl.className = 'print-footer';
  const divider = document.createElement('div');
  divider.className = 'print-footer-divider';
  const footerTitle = document.createElement('p');
  footerTitle.className = 'print-footer-title';
  footerTitle.textContent = t.printAutoGenerated;
  const footerMeta = document.createElement('p');
  footerMeta.className = 'print-footer-meta';
  footerMeta.textContent = `${dateStr}, ${timeStr} · ${t.printBasedOn} ${reportData.transactionCount} ${txLabel}`;
  const footerDisclaimer = document.createElement('p');
  footerDisclaimer.className = 'print-footer-disclaimer';
  footerDisclaimer.textContent = t.printPersonalUseOnly;
  const footerUrl = document.createElement('p');
  footerUrl.className = 'print-footer-url';
  footerUrl.textContent = t.printDomain;
  footerEl.append(divider, footerTitle, footerMeta, footerDisclaimer, footerUrl);

  // Clear and populate print container using DOM APIs (no innerHTML)
  printContainer.textContent = '';
  printContainer.append(brandingEl, headerEl);

  // Remove the print-only elements from clone (they're now in the container)
  const printOnlyElements = clone.querySelectorAll('[data-testid="print-app-branding"], [data-testid="print-header"]');
  printOnlyElements.forEach(el => el.remove());

  // Add cloned content
  printContainer.appendChild(clone);

  // Add footer at the end
  printContainer.appendChild(footerEl);

  // Add print-ready class to body
  document.body.classList.add('printing-report');

  // Print
  window.print();

  // Cleanup after print dialog closes (guarded against double-execution)
  let cleaned = false;
  const cleanup = () => {
    if (cleaned) return;
    cleaned = true;
    document.body.classList.remove('printing-report');
    document.title = originalTitle; // Restore original title
    if (printContainer) {
      printContainer.textContent = '';
    }
  };

  // Use both events to ensure cleanup
  window.addEventListener('afterprint', cleanup, { once: true });
  // Fallback timeout in case afterprint doesn't fire
  setTimeout(cleanup, 1000);
};
