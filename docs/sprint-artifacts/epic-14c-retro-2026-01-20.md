# Retrospective: Epic 14c - Shared Groups (FAILED)

**Date:** 2026-01-20
**Facilitator:** Bob (Scrum Master)
**Participants:** Gabe (Product Owner/Project Lead), Dev Team (AI Agents)
**Epic Status:** REVERTED to commit 68686f3
**Outcome:** Epic failed - requires complete reset and redesign

---

## Executive Summary

Epic 14c (Shared Groups) was reverted after 3 days of attempting to fix cascading synchronization issues. The epic delivered working UI components but failed on the core real-time sync requirement. This retrospective captures the root causes and defines the path forward.

**Key Decision:** Reset Epic 14c completely. Create intermediate refactoring epic before reattempting shared groups.

---

## Epic Summary

| Metric | Value |
|--------|-------|
| **Stories Attempted** | 23 |
| **Stories "Done"** | 18 |
| **Stories Reverted** | 1 (14c.23 - revert to stable baseline) |
| **Stories Abandoned** | 14c.20 (cache optimization), 14c.99 (release) |
| **Production Status** | **REVERTED** to commit 68686f3 |
| **Root Cause** | Architectural gaps discovered mid-implementation |

---

## What Worked

| Component | Status | Notes |
|-----------|--------|-------|
| UI Components | ‚úÖ Working | View mode switcher, ownership indicators, group management |
| Security Rules | ‚úÖ Working | Group membership validation, role permissions |
| Cloud Function | ‚úÖ Working | `getSharedGroupTransactions` for cross-user queries |
| Group CRUD | ‚úÖ Working | Create, join, leave, manage groups |
| Transaction Tagging | ‚úÖ Working | Users can tag transactions to groups |
| VAPID Push Notifications | ‚úÖ Working | Cross-user update notifications |
| Test Coverage | ‚úÖ Working | ~4600 tests covering the feature |

---

## What Failed: The Three Compounding Problems

### Problem 1: Deletion Detection Gap

**Symptom:** When User A untags a transaction from a shared group, User B still sees it.

**Root Cause:** Delta sync (fetching changes since last sync) cannot detect *removals* by design. You can see new/modified data, but you cannot see "what's missing."

**Attempted Fixes:**
1. Added `removedFromGroupIds` field - never fully wired
2. Tried count-based detection (compare local count vs server count)
3. Each fix added complexity without solving the core issue

**Lesson:**
> Delta sync cannot detect deletions by default. Before implementing any real-time sync, explicitly design for:
> 1. How additions are detected ‚úÖ (easy)
> 2. How modifications are detected ‚úÖ (easy)
> 3. How deletions are detected ‚ùå (requires explicit design: soft delete, tombstones, or version vectors)

---

### Problem 2: State Staleness After First Operation

**Symptom:** First sync operation worked fine. Second operation failed. Pattern: works ‚Üí fails ‚Üí works ‚Üí fails.

**Root Cause:** The `prevMemberUpdatesRef` (used to track "what I already processed") wasn't updating correctly after handling the first event. Subsequent changes were either:
- Not detected (ref still held old state)
- Detected but ignored (React Query staleTime)
- Lost due to listener issues

**Code Pattern That Failed:**
```typescript
const prevMemberUpdatesRef = useRef<Record<string, MemberUpdate>>({});

useEffect(() => {
  // Compare current vs previous
  // ... detection logic ...

  // UPDATE REF FOR NEXT COMPARISON
  // üëÜ If this had a bug, second operation fails silently
  prevMemberUpdatesRef.current = /* new state */;
}, [sharedGroups]);
```

**Lesson:**
> A sync mechanism that works for ONE operation may fail on SUBSEQUENT operations. Always test at least 3 consecutive operations:
> - Operation 1 (initial ‚Üí first change)
> - Operation 2 (changed ‚Üí second change)
> - Operation 3 (verify pattern holds)
>
> Single-operation tests give false confidence.

---

### Problem 3: Cost Explosion from Full Refetch Fallback

**Symptom:** Firestore read costs spiked dramatically.

**Root Cause:** When delta sync broke, the "fix" was `refetchOnMount: true` - fetch all transactions on every component mount. This turned O(delta) into O(all √ó navigations).

**Cost Projection (if shipped):**
| Factor | Value |
|--------|-------|
| Transactions per user | ~500 (2 years) |
| Groups per user | 5 |
| Navigations per session | ~10 |
| Sessions per day | 2 |
| **Reads per user per day** | **50,000** |
| **100 users** | **5,000,000 reads/day = $3/day** |
| **1000 users** | **$30/day = $900/month** |

**Lesson:**
> Caching is a cost control mechanism, not just performance. When delta sync breaks:
> - STOP and fix it properly
> - Or DESCOPE the feature
> - Do NOT ship with `refetchOnMount: true` as a band-aid
>
> Full refetch fallback can bankrupt the product.

---

## The Failure Cascade

```
Day 1: Delta sync doesn't detect deleted transactions
       ‚Üì
Day 1: "Fix" - add count comparison logic
       ‚Üì
Day 2: Count logic breaks other things, state gets stale after first operation
       ‚Üì
Day 2: "Fix" - refetchOnMount: true (bypass caching entirely)
       ‚Üì
Day 3: Firestore costs spike, performance degrades
       ‚Üì
Day 3: Realize the architecture is fundamentally broken
       ‚Üì
Day 3: REVERT to commit 68686f3
```

---

## Previous Retrospective Follow-Through

From Epic 12/13/14 retrospective (2026-01-15):

| Previous Commitment | Applied in 14c? | Result |
|---------------------|-----------------|--------|
| "Refactor legacy before extending" | ‚ùå NO | Extended existing transaction system without refactoring first |
| "Run brainstorming before complex features" | ‚úÖ YES | Ran brainstorming Jan 15 - but missed deletion problem |
| "Large files = context problems" | ‚ùå NO | App.tsx grew even larger with sync logic |
| "Epic completion gates" | ‚ùå NO | Would have caught cost issues earlier |

**Result:** Key lessons from previous retro were NOT applied, contributing to failure.

---

## Decision: Epic Reset and Restructuring

### New Epic Structure

| Epic | Name | Purpose |
|------|------|---------|
| **14c-refactor** | Codebase Cleanup | Prepare clean foundation before shared groups |
| **14d** | Shared Groups v2 | Reimplemented with lessons learned |

### Epic 14c-refactor Scope

| Area | Work Required |
|------|---------------|
| **App.tsx** | Break down ~3800 lines into contexts/hooks |
| **Transaction Service** | Consolidate/simplify caching layers |
| **View Mode State** | Unify localStorage/Firestore/Context |
| **Cloud Functions** | Audit, cleanup, consolidate |
| **Firebase Indexes** | Audit and optimize |
| **Shared Group Cleanup** | Remove dead code, reset sharedGroupIds fields |

### Epic 14d Constraints (Finalized)

| Constraint | Value |
|------------|-------|
| **Time window** | 2 years max |
| **Max groups/user** | 5 |
| **Max contributors/group** | 10 |
| **Max viewers/group** | 200 |
| **Roles** | Owner (manage + transfer + edit icon/color), Contributor (read/write), Viewer (read-only) |
| **Real-time sync** | Last 60 days only |
| **Older data** | On-demand refresh with cooldown |
| **Refresh cooldown** | 1 min (first 3 attempts), 15 min (after), resets daily |
| **Deletion strategy** | Must use soft delete (design upfront) |
| **Notifications** | Keep VAPID Web Push system |
| **Mode persistence** | Required across sessions |

---

## Action Items

| # | Action | Owner | Priority | Due |
|---|--------|-------|----------|-----|
| 1 | Archive current 14c stories (rename to 14c-old or 14d-failed) | SM | HIGH | Before next sprint |
| 2 | Create Epic 14c-refactor definition and stories | Architect | HIGH | Before next sprint |
| 3 | Create Epic 14d definition with constraints | Architect | HIGH | After 14c-refactor |
| 4 | Run architecture brainstorm for 14d sync strategy | Architect + Gabe | HIGH | Before 14d stories |
| 5 | Add lessons to Atlas 06-lessons.md | Dev Team | MEDIUM | This week |
| 6 | Set up Firestore cost monitoring dashboard | Gabe | MEDIUM | Before 14d launch |
| 7 | Design soft delete pattern for transaction untagging | Architect | HIGH | In 14d brainstorm |
| 8 | Create multi-operation test suite template | QA | MEDIUM | Before 14d |

---

## Architecture Requirements for 14d Brainstorm

Before starting Epic 14d, the brainstorm session must answer:

1. **Deletion Detection:** Soft delete pattern? Tombstone records? Concrete implementation.
2. **State Management:** How to prevent "first works, second fails"? Explicit version tracking?
3. **Cache Layers:** React Query only? Remove IndexedDB? Simplify.
4. **Sync Boundaries:** 60-day real-time window implementation details.
5. **Manual Refresh:** Cooldown mechanism and UI placement (Settings + Home screen logo).
6. **Cost Monitoring:** Alerts and dashboards before launch.
7. **Testing Strategy:** Multi-operation test sequences as requirement.

---

## Lessons for Atlas Knowledge Base

### Lesson 1: Deletion Detection in Delta Sync

```markdown
## Deletion Detection in Delta Sync

Delta sync (fetching only changes since last sync) CANNOT detect removals by default.

Before implementing real-time sync:
1. Additions: Easy - new data appears
2. Modifications: Easy - updated timestamp
3. Deletions: HARD - requires explicit design

Solutions:
- Soft delete: Mark as `deleted: true`, delta sees the flag
- Tombstones: Write "this was deleted" marker records
- Version vectors: Track versions, detect gaps
- Periodic full refresh: Simple but expensive

**Never discover this gap mid-implementation.**
```

### Lesson 2: Multi-Operation Testing

```markdown
## Multi-Operation Testing for Sync

A sync that works for ONE operation may fail on SUBSEQUENT operations.

Causes:
- State not resetting (refs, caches, flags)
- Listeners unsubscribing after first event
- Cache freshness ignoring second invalidation
- Race conditions

**Required testing:**
1. Operation 1 (initial ‚Üí first change)
2. Operation 2 (changed ‚Üí second change)
3. Operation 3 (verify pattern holds)

Single-operation tests give FALSE CONFIDENCE.
```

### Lesson 3: Caching as Cost Control

```markdown
## Caching is Cost Control

In multi-user shared data systems, caching directly impacts costs:

- Full refetch on mount: O(all √ó users √ó navigations) = exponential cost
- Delta sync with caching: O(changes) = linear cost

**When delta sync breaks:**
- STOP and fix properly
- Or DESCOPE the feature
- Do NOT ship refetchOnMount: true as band-aid

Full refetch fallback can bankrupt the product.
```

---

## Closing Thoughts

Charlie (Senior Dev): "This was a painful but valuable failure. We now know exactly what NOT to do."

Dana (QA Engineer): "The good news: all the UI work is salvageable. We just need to fix the data layer."

Alice (Product Owner): "And we have concrete constraints now - 5 groups, 10 contributors, 60-day real-time window. That's designable."

Bob (Scrum Master): "The key insight is we tried to solve a hard distributed systems problem without respecting its complexity. Now we will."

Gabe (Project Lead): "Reset, refactor, then rebuild with eyes open."

---

## Next Steps

1. **Immediate:** Save this retrospective, update sprint-status.yaml
2. **This Week:** Create Epic 14c-refactor definition
3. **Before 14d:** Run thorough architecture brainstorm with deletion strategy
4. **14d Start:** Only after 14c-refactor complete and brainstorm done

---

## References

- [Original Brainstorm Decision](./epic14c/BRAINSTORM-REALTIME-SYNC-DECISION.md)
- [Story 14c.12: Real-Time Sync](./epic14c/14c-12-realtime-sync-complete-circuit.md)
- [Story 14c.23: Revert to Stable Baseline](./epic14c/14c-23-revert-to-stable-baseline.md)
- [Previous Retro (Epics 12/13/14)](./epic12-13-14-retro-2026-01-15.md)
- [Sprint Status](./sprint-status.yaml)
- [Atlas Lessons](../../_bmad/agents/atlas/atlas-sidecar/knowledge/06-lessons.md)

---

*Generated by BMAD Retrospective Workflow*
*Epic: shared-groups-failed*
*Retrospective Date: 2026-01-20*
