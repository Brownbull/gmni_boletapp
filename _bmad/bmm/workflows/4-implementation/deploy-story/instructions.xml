<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>

  <critical>This workflow deploys a completed story through the 2-branch PR-based pipeline</critical>
  <critical>NEVER push directly to develop or main - always use PRs via `gh pr create` + `gh pr merge`</critical>
  <critical>NEVER use `git merge` to merge into protected branches - use `gh pr merge` instead</critical>
  <critical>Pre-deployment validation is REQUIRED before production deployment</critical>

  <step n="1" goal="Verify story is ready for deployment">
    <action>If {{story_path}} not provided, ask user which story to deploy</action>
    <action>Read COMPLETE story file</action>
    <action>Extract {{story_key}} from filename</action>
    <action>Extract story Status field</action>

    <check if="story status != 'done'">
      <output>**DEPLOYMENT BLOCKED**

        Story status is "{{story_status}}" - must be "done" to deploy.

        Run `code-review` first to complete the story.</output>
      <action>EXIT workflow</action>
    </check>

    <action>Run `git status --porcelain` to check for uncommitted changes</action>
    <check if="uncommitted changes exist">
      <output>**WARNING: Uncommitted Changes Detected**

        Please commit or stash changes before deployment.</output>
      <ask>Commit changes now? [Y/N]</ask>
      <check if="user says Y">
        <action>Stage relevant files with `git add` (specific files, not -A)</action>
        <action>Run `git commit -m "chore: pre-deployment cleanup for {{story_key}}"`</action>
      </check>
      <check if="user says N">
        <output>Deployment cancelled. Commit changes and retry.</output>
        <action>EXIT workflow</action>
      </check>
    </check>

    <action>Detect current branch with `git branch --show-current`</action>
    <action>Set {{current_branch}} = result</action>

    <check if="{{current_branch}} == 'main' OR {{current_branch}} == 'develop'">
      <output>**DEPLOYMENT BLOCKED**

        You are on a protected branch ({{current_branch}}).
        Deployments must originate from a feature/fix/chore branch.

        Create a feature branch first: `git checkout -b feature/...`</output>
      <action>EXIT workflow</action>
    </check>

    <output>**Story Ready for Deployment**

      **Story:** {{story_key}}
      **Current Branch:** {{current_branch}}
      **Status:** done

      Deployment pipeline: {{current_branch}} -> develop (squash PR) -> main (merge PR)</output>
  </step>

  <step n="2" goal="Pre-deployment validation">
    <critical>Validate deployment against project patterns before any PRs</critical>

    <action>Load project patterns from {project-root}/_bmad/bmm/knowledge/code-review-patterns.md</action>
    <action>Load architecture docs from {project-root}/docs/architecture/</action>

    <output>**Pre-Deployment Validation**

      Checking alignment with documented architecture and patterns...</output>

    <!-- Cross-cutting impact analysis -->
    <action>Identify workflows affected by this story's changes:
      1. Parse story acceptance criteria for user journey references
      2. Map file changes to affected features
      3. Identify downstream impacts
    </action>

    <!-- Architectural alignment -->
    <action>Check implementation against architecture docs:
      1. Verify patterns used match documented ADRs
      2. Check for undocumented architectural decisions
      3. Flag any deviations from standards
    </action>

    <check if="critical architectural conflicts found">
      <output>**DEPLOYMENT BLOCK**

        Critical architectural conflicts detected:
        {{conflict_list}}

        Resolve these issues before deployment.</output>
      <ask>Override deployment block? (Not recommended) [Y/N]</ask>
      <check if="user says N">
        <action>EXIT workflow</action>
      </check>
      <check if="user says Y">
        <action>Log override decision</action>
        <output>Deployment block overridden by user. Proceeding with caution.</output>
      </check>
    </check>

    <output>**Validation: PASSED**

      Patterns validated: {{chain_count}}
      Architectural alignment: Confirmed
      Downstream impacts: {{impact_summary}}</output>
  </step>

  <step n="3" goal="Create PR to develop (squash merge)">
    <action>Run `git fetch origin`</action>
    <action>Run `git push -u origin {{current_branch}}`</action>

    <output>**Step 1/2: PR to develop**

      Creating PR: {{current_branch}} -> develop (squash merge)

      This integrates your feature into the development branch.</output>

    <ask>Proceed with PR to develop? [Y/N]</ask>
    <check if="user says N">
      <output>Deployment paused. Resume when ready.</output>
      <action>EXIT workflow</action>
    </check>

    <action>Run `gh pr create --base develop --title "{{story_key}}: {{story_title}}" --body "## Summary

{{story_summary}}

## Story
{{story_key}}

## Acceptance Criteria
{{acceptance_criteria_summary}}

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"`</action>

    <action>Set {{develop_pr_url}} = PR URL from output</action>

    <output>**PR Created:** {{develop_pr_url}}

      Waiting for CI checks to pass...</output>

    <action>Run `gh pr checks {{develop_pr_url}} --watch` to wait for CI</action>

    <check if="CI checks fail">
      <output>**CI CHECKS FAILED**

        Fix the failing checks on branch {{current_branch}} and push again.
        The PR will re-run CI automatically.

        Do NOT bypass CI - fix the issue first.</output>
      <action>EXIT workflow</action>
    </check>

    <output>**CI Checks Passed**

      Squash-merging PR to develop...</output>

    <action>Run `gh pr merge {{develop_pr_url}} --squash --delete-branch`</action>

    <check if="merge fails">
      <output>**MERGE FAILED**

        Check the PR for merge conflicts or review requirements.
        Resolve and retry.</output>
      <action>EXIT workflow</action>
    </check>

    <output>**Merged to develop (squash)**

      Feature branch {{current_branch}} auto-deleted.
      CI validates on push to develop.</output>
  </step>

  <step n="4" goal="Create PR to main (merge commit)">
    <action>Run `git checkout develop`</action>
    <action>Run `git pull origin develop`</action>

    <output>**Step 2/2: PR to main (production)**

      Creating PR: develop -> main (merge commit, preserves history)

      This deploys to production via Firebase auto-deploy on merge to main.</output>

    <ask>**FINAL CONFIRMATION**: Create PR to main for production deployment? [Y/N]</ask>
    <check if="user says N">
      <output>Deployment paused at develop. Story is integrated but not in production.
        You can create the PR to main later.</output>
      <action>Set {{final_environment}} = "develop"</action>
      <action>GOTO step 6</action>
    </check>

    <action>Run `gh pr create --base main --title "Release: {{story_key}}" --body "## Release

Promoting develop to main for story {{story_key}}.

## Changes
{{story_summary}}

Auto-deploys to Firebase on merge.

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>"`</action>

    <action>Set {{main_pr_url}} = PR URL from output</action>

    <output>**PR Created:** {{main_pr_url}}

      Waiting for CI checks to pass...</output>

    <action>Run `gh pr checks {{main_pr_url}} --watch` to wait for CI</action>

    <check if="CI checks fail">
      <output>**CI CHECKS FAILED**

        Fix the failing checks on develop and push again.
        The PR will re-run CI automatically.

        Do NOT bypass CI - fix the issue first.</output>
      <action>EXIT workflow</action>
    </check>

    <output>**CI Checks Passed**

      Merge-committing PR to main...</output>

    <action>Run `gh pr merge {{main_pr_url}} --merge`</action>

    <check if="merge fails">
      <output>**MERGE FAILED**

        Check the PR for merge conflicts or review requirements.
        Resolve and retry.</output>
      <action>EXIT workflow</action>
    </check>

    <action>Set {{final_environment}} = "production"</action>

    <output>**Deployed to production**

      Firebase auto-deploy triggered on merge to main.
      Production URL: {deployment_urls.production}</output>
  </step>

  <step n="5" goal="Branch cleanup and sync">
    <action>Run `git fetch --prune`</action>
    <action>Run `git checkout develop`</action>
    <action>Run `git pull origin develop`</action>

    <output>**Branch Cleanup**

      Remote branches pruned.
      Local develop branch synced with origin.</output>
  </step>

  <step n="6" goal="Update sprint status">
    <check if="{sprint_status} file exists">
      <action>Load {sprint_status}</action>
      <action>Update development_status[{{story_key}}] = "deployed"</action>
      <action>Add deployed_to: {{final_environment}}</action>
      <action>Add deployed_at: {{date}}</action>
      <action>Save file preserving structure</action>
      <output>Sprint status updated: {{story_key}} -> deployed ({{final_environment}})</output>
    </check>
  </step>

  <step n="7" goal="Deployment summary">
    <output>**DEPLOYMENT COMPLETE**

      **Story:** {{story_key}}
      **Final Environment:** {{final_environment}}
      **Production URL:** {deployment_urls.production}

      **Pipeline Executed:**
      - Story status verified (done)
      - Pre-deployment validation passed
      - PR to develop (squash merge) {{#if develop_pr_url}}{{develop_pr_url}}{{/if}}
      {{#if final_environment == 'production'}}- PR to main (merge commit) {{main_pr_url}}
      - Firebase auto-deploy triggered{{else}}- Production deployment skipped{{/if}}
      - Branches cleaned up
      - Sprint status synced

      **Next Steps:**
      - Verify production functionality at {deployment_urls.production}
      - Run `/sprint-status` to see sprint progress
      - Continue with next story via `/ecc-create-story`</output>
  </step>

</workflow>
