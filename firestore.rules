rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // ============================================================================
    // Transaction Access - Owner Only
    // Simplified after Epic 14c-refactor: Cross-user shared group access removed
    // ============================================================================
    match /artifacts/{appId}/users/{userId}/transactions/{transactionId} {
      // Owner can read and write their own transactions
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================================================
    // Collection Group Query - Denied
    // Client-side collection group queries disabled for security (2026-01-17)
    // ============================================================================
    match /{path=**}/transactions/{transactionId} {
      allow read: if false;
    }

    // ============================================================================
    // User Data Isolation
    // Each user can only access their own data (all subcollections)
    // ============================================================================
    match /artifacts/{appId}/users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================================================
    // Shared Groups - Epic 14d-v2: Shared Groups v2
    // Changelog-driven sync architecture with double-gate privacy model
    // Story 14d-v2-1-4a: Types & Security Rules Foundation
    // ============================================================================
    match /sharedGroups/{groupId} {
      // Helper: Is user authenticated and the owner of this group?
      function isGroupOwner() {
        return request.auth != null &&
               request.auth.uid == resource.data.ownerId;
      }

      // Helper: Is user authenticated and a member (for subcollection access)?
      function isGroupMemberForSubcollection() {
        return request.auth != null &&
               request.auth.uid in get(/databases/$(database)/documents/sharedGroups/$(groupId)).data.members;
      }

      // Read: Any authenticated user can read group documents
      // Group metadata (name, color, members) is NOT sensitive financial data.
      // Transaction data remains strictly isolated in per-user subcollections.
      // Non-member reads are required for:
      //   - Share code lookups (JoinGroupByCode -> getGroupByShareCode)
      //   - Invitation acceptance (AcceptInvitationDialog -> getDoc for group details)
      //   - Join transactions (acceptInvitation -> transaction.get for validation)
      // Story 14d-v2-1-14-polish: Fixed from member-only to authenticated
      allow read: if request.auth != null;

      // Create: Authenticated users can create groups
      // AC#2: BC-1 (max 5 groups) is enforced client-side via SHARED_GROUP_LIMITS.MAX_OWNED_GROUPS
      // Server-side enforcement would require a read operation which is expensive
      // Client validates the limit before allowing group creation
      allow create: if request.auth != null;

      // Helper: Is user joining the group (adding themselves to members)?
      // Used for share code joining where non-members can add themselves
      function isUserJoining() {
        let oldMembers = resource.data.members;
        let newMembers = request.resource.data.members;
        let userId = request.auth.uid;

        // User must not already be a member
        // User must be adding only themselves to members array
        // Members array must grow by exactly 1
        return !(userId in oldMembers)
            && userId in newMembers
            && newMembers.size() == oldMembers.size() + 1;
      }

      // Helper: Is user leaving the group (removing themselves from members)?
      // Story 14d-v2-1-7a: Allow members to remove themselves from groups
      // ECC Review: Security fix - members must be able to leave
      function isUserLeaving() {
        let oldMembers = resource.data.members;
        let newMembers = request.resource.data.members;
        let userId = request.auth.uid;

        // User must be a current member
        // User must be removing only themselves
        // Members array must shrink by exactly 1
        // Owner cannot use the leave path (must transfer/delete instead)
        // Only members array and updatedAt can change
        return userId in oldMembers
            && !(userId in newMembers)
            && newMembers.size() == oldMembers.size() - 1
            && resource.data.ownerId != userId
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'updatedAt']);
      }

      // Helper: Is settings update allowed (60s cooldown)?
      // TD-CONSOLIDATED-11: Server-side rate limiting for owner settings updates
      // Migration-safe: allows updates when field is missing or null (pre-existing groups)
      // Timestamp validation: lastSettingsUpdateAt MUST be written and MUST equal
      // request.time (enforces serverTimestamp(), prevents future timestamp lock-out attack
      // and prevents bypass via omitting the field from the write)
      function isSettingsUpdateAllowed() {
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        // lastSettingsUpdateAt MUST be written and MUST equal request.time
        // ECC Review Fix: Changed from optional to mandatory to prevent cooldown bypass
        // where a malicious client omits the field, keeping the old expired value
        let timestampWritten = changedKeys.hasAny(['lastSettingsUpdateAt'])
            && request.resource.data.lastSettingsUpdateAt == request.time;
        // Cooldown check on existing value (migration-safe)
        let cooldownPassed = !('lastSettingsUpdateAt' in resource.data)
            || resource.data.lastSettingsUpdateAt == null
            || request.time > resource.data.lastSettingsUpdateAt + duration.value(60, 's');
        return timestampWritten && cooldownPassed;
      }

      // Helper: Is this an ownership transfer? (not subject to settings cooldown)
      // ECC Review Fix: Ownership transfer writes {ownerId, updatedAt} or
      // {ownerId, members, updatedAt} (transfer + leave combo). Without a dedicated
      // path, transfers would be incorrectly blocked by the 60s settings cooldown.
      // Requires ownerId to be changing (prevents non-transfer member modifications).
      function isOwnershipTransfer() {
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        return changedKeys.hasAny(['ownerId'])
            && changedKeys.hasOnly(['ownerId', 'updatedAt', 'members']);
      }

      // Helper: Is this a transaction sharing toggle update?
      // TD-CONSOLIDATED-11: Toggle has its own independent cooldown system
      // (transactionSharingLastToggleAt, not lastSettingsUpdateAt)
      // Must be a separate update path to avoid settings cooldown blocking toggles
      function isTransactionSharingToggle() {
        return request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['transactionSharingEnabled', 'transactionSharingLastToggleAt',
                      'transactionSharingToggleCountToday', 'transactionSharingToggleCountResetAt',
                      'updatedAt']);
      }

      // Helper: Is delete allowed (30s cooldown)?
      // TD-CONSOLIDATED-11: Server-side rate limiting for group deletions
      // Uses existing updatedAt field (set on creation and any modification)
      // Note: updatedAt is written by ALL operations (settings, toggle, join, leave),
      // so this enforces "30s since last modification by anyone" â€” acceptable
      // trade-off to avoid adding a dedicated lastDeleteAttemptAt field.
      function isDeleteAllowed() {
        return !('updatedAt' in resource.data)
            || resource.data.updatedAt == null
            || request.time > resource.data.updatedAt + duration.value(30, 's');
      }

      // Update: Owner can update settings (with cooldown), toggle sharing, transfer ownership, or members can join/leave
      // AC#4: Non-owners cannot update (except to join or leave)
      // Story 14d-v2-1-6c-2: Allow joining via share code
      // Story 14d-v2-1-7a: Allow members to leave group
      // Story 14d-v2-1-11b: Transaction sharing toggle (owner-only, independent cooldown)
      // TD-CONSOLIDATED-11: Settings updates gated by 60s cooldown, toggle and transfer have separate paths
      allow update: if (isGroupOwner() && (isSettingsUpdateAllowed() || isTransactionSharingToggle() || isOwnershipTransfer())) || (request.auth != null && isUserJoining()) || (request.auth != null && isUserLeaving());

      // Delete: Only owner can delete group
      // AC#4: Non-owners cannot delete
      // TD-CONSOLIDATED-11: isDeleteAllowed() gates deletes with 30s cooldown
      allow delete: if isGroupOwner() && isDeleteAllowed();

      // ========================================================================
      // Changelog Subcollection - Epic 14d-v2 Story 1.3b
      // Append-only changelog for transaction sync between group members
      // TTL: 30 days (AD-9) - configured via Firebase Console
      // ========================================================================
      match /changelog/{changeId} {
        // Helper: Validate changelog entry structure
        // Note: Cloud Functions using Admin SDK bypass security rules entirely,
        // so actorId == auth.uid is safe to enforce for client-side writes
        function isValidChangelogEntry() {
          let entry = request.resource.data;
          return entry.type in ['TRANSACTION_ADDED', 'TRANSACTION_MODIFIED', 'TRANSACTION_REMOVED']
              && entry.transactionId is string
              && entry.transactionId.size() > 0
              && entry.actorId == request.auth.uid
              && entry.groupId is string
              && entry.groupId == groupId
              && entry.timestamp is timestamp
              && entry._ttl is timestamp
              && entry.summary is map
              && entry.summary.amount is number
              && entry.summary.currency is string
              && entry.summary.description is string;
        }

        // Read: Group members only
        allow read: if isGroupMemberForSubcollection();

        // Create: Group members only with validation
        allow create: if isGroupMemberForSubcollection() && isValidChangelogEntry();

        // Update/Delete: FORBIDDEN (append-only pattern)
        allow update, delete: if false;
      }
    }

    // ============================================================================
    // Pending Invitations - Epic 14d-v2 Story 1.5b-2, 1.6e
    // Invitations for joining shared groups
    // Status can be updated by invited user (accept/decline)
    // ============================================================================
    match /pendingInvitations/{invitationId} {
      // Helper: Check if user is the owner of the group referenced in the invitation
      // For create: uses request.resource.data (new document)
      // For delete: uses resource.data (existing document)
      function isGroupOwnerForInvitation(groupId) {
        return exists(/databases/$(database)/documents/sharedGroups/$(groupId))
            && get(/databases/$(database)/documents/sharedGroups/$(groupId)).data.ownerId == request.auth.uid;
      }

      // Helper: Check if this is a valid status update (accept/decline)
      // Story 14d-v2-1-6e: Task 11.1-11.3
      // Allows: authenticated user whose email matches the invited email
      // Only: changing status from 'pending' to 'accepted' or 'declined'
      function isValidStatusUpdate() {
        // Must be authenticated
        // Email must match (case-insensitive via normalized storage)
        // Current status must be 'pending'
        // New status must be terminal ('accepted' or 'declined')
        // Only the status field can be changed
        return request.auth != null
            && resource.data.invitedEmail == request.auth.token.email
            && resource.data.status == 'pending'
            && request.resource.data.status in ['accepted', 'declined']
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
      }

      // Create: Only authenticated group owners can create invitations (AC #3)
      // Verifies the group exists and the creator is the group owner
      allow create: if request.auth != null
        && request.resource.data.groupId is string
        && isGroupOwnerForInvitation(request.resource.data.groupId);

      // Get (single document by ID): Any authenticated user can read
      // Needed for accept/decline flows that use document IDs
      allow get: if request.auth != null;

      // List (collection query): Restricted to own invitations or own-created invitations
      // TD-CONSOLIDATED-5: Restrict pendingInvitations list to prevent email/status exposure
      // Two valid query patterns:
      //   1. Invitee: filter by invitedEmail == auth email (view own invitations)
      //   2. Inviter: filter by invitedByUserId == auth uid (owner cleanup on group deletion)
      // Note: App uses Google Sign-In exclusively, so all users have email in token
      allow list: if request.auth != null
        && (
          (request.auth.token.email != null
            && resource.data.invitedEmail == request.auth.token.email)
          || resource.data.invitedByUserId == request.auth.uid
        );

      // Update: Only invited user can accept/decline (Story 14d-v2-1-6e AC #1)
      // Validates: email matches, status is pending, new status is terminal
      allow update: if isValidStatusUpdate();

      // Delete: Only group owner can delete/cancel invitations (AC #3)
      allow delete: if request.auth != null
        && resource.data.groupId is string
        && isGroupOwnerForInvitation(resource.data.groupId);
    }

    // ============================================================================
    // Default Deny - All other paths
    // ============================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
