rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // User isolation: Each user can only access their own data
    match /artifacts/{appId}/users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================================================
    // Story 14c.1: Shared Groups (top-level collection)
    // Epic 14c: Household Sharing
    //
    // Architecture: Option 4 - Hybrid Model
    // - SharedGroup documents stored at top-level for cross-user access
    // - Members can read, only owner can write/delete
    // ============================================================================
    match /sharedGroups/{groupId} {
      // Helper: Check if user is authenticated
      function isAuthenticated() {
        return request.auth != null;
      }

      // Helper: Check if user is a member of this group
      function isGroupMember() {
        return isAuthenticated()
            && request.auth.uid in resource.data.members;
      }

      // Helper: Check if user is the owner of this group
      function isGroupOwner() {
        return isAuthenticated()
            && request.auth.uid == resource.data.ownerId;
      }

      // Helper: Validate new group creation
      // - User must be owner
      // - Members array must contain only the creator
      function isValidNewGroup() {
        return isAuthenticated()
            && request.resource.data.ownerId == request.auth.uid
            && request.resource.data.members.hasOnly([request.auth.uid])
            && request.resource.data.members.size() == 1;
      }

      // CREATE: Authenticated user creating a group they own
      allow create: if isValidNewGroup();

      // READ: Must be a member of the group
      allow read: if isGroupMember();

      // Helper: Check if user is being added as a member (accepting invitation)
      // Allows adding the current user to members array if they're not already a member
      function isJoiningGroup() {
        return isAuthenticated()
            && !(request.auth.uid in resource.data.members)
            && request.auth.uid in request.resource.data.members
            && request.resource.data.members.size() == resource.data.members.size() + 1
            && resource.data.members.size() < 10; // MAX_MEMBERS_PER_GROUP
      }

      // UPDATE: Owner can update anything, or user can add themselves as member
      allow update: if isGroupOwner() || isJoiningGroup();

      // DELETE: Only owner can delete the group
      allow delete: if isGroupOwner();
    }

    // ============================================================================
    // Story 14c.2: Pending Invitations (top-level collection)
    // Epic 14c: Household Sharing
    //
    // Pending invitations are email-based invitations to join shared groups.
    // - Invited user can read invitations addressed to their email
    // - Group owner/member can create invitations
    // - Invited user can accept/decline (update status only)
    // ============================================================================
    match /pendingInvitations/{invitationId} {
      // Helper: Check if user is authenticated
      function isAuthenticated() {
        return request.auth != null;
      }

      // Helper: Check if the invitation is addressed to the current user's email
      function isInvitedUser() {
        return isAuthenticated()
            && request.auth.token.email != null
            && resource.data.invitedEmail == request.auth.token.email.lower();
      }

      // Helper: Check if user is updating only the status field (accept/decline)
      function isStatusUpdateOnly() {
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
            && request.resource.data.status in ['accepted', 'declined'];
      }

      // CREATE: Any authenticated user can create invitations
      // In practice, the app restricts this to group owners/members
      allow create: if isAuthenticated()
          && request.resource.data.invitedByUserId == request.auth.uid;

      // READ: User can read invitations addressed to their email
      allow read: if isInvitedUser();

      // UPDATE: Invited user can accept/decline (only status field)
      allow update: if isInvitedUser() && isStatusUpdateOnly();

      // DELETE: Not allowed (invitations are kept for audit trail)
      allow delete: if false;
    }

    // Deny all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
