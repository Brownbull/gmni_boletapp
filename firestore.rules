rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // ============================================================================
    // Transaction Access - Owner Only
    // Simplified after Epic 14c-refactor: Cross-user shared group access removed
    // ============================================================================
    match /artifacts/{appId}/users/{userId}/transactions/{transactionId} {
      // Owner can read and write their own transactions
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================================================
    // Collection Group Query - Denied
    // Client-side collection group queries disabled for security (2026-01-17)
    // ============================================================================
    match /{path=**}/transactions/{transactionId} {
      allow read: if false;
    }

    // ============================================================================
    // User Data Isolation
    // Each user can only access their own data (all subcollections)
    // ============================================================================
    match /artifacts/{appId}/users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================================================
    // Shared Groups - Epic 14d-v2: Shared Groups v2
    // Changelog-driven sync architecture with double-gate privacy model
    // Story 14d-v2-1-4a: Types & Security Rules Foundation
    // ============================================================================
    match /sharedGroups/{groupId} {
      // Helper: Is user authenticated and the owner of this group?
      function isGroupOwner() {
        return request.auth != null &&
               request.auth.uid == resource.data.ownerId;
      }

      // Helper: Is user authenticated and a member (for subcollection access)?
      function isGroupMemberForSubcollection() {
        return request.auth != null &&
               request.auth.uid in get(/databases/$(database)/documents/sharedGroups/$(groupId)).data.members;
      }

      // Read: Any authenticated user can read group documents
      // Group metadata (name, color, members) is NOT sensitive financial data.
      // Transaction data remains strictly isolated in per-user subcollections.
      // Non-member reads are required for:
      //   - Share code lookups (JoinGroupByCode -> getGroupByShareCode)
      //   - Invitation acceptance (AcceptInvitationDialog -> getDoc for group details)
      //   - Join transactions (acceptInvitation -> transaction.get for validation)
      // Story 14d-v2-1-14-polish: Fixed from member-only to authenticated
      allow read: if request.auth != null;

      // Create: Authenticated users can create groups
      // AC#2: BC-1 (max 5 groups) is enforced client-side via SHARED_GROUP_LIMITS.MAX_OWNED_GROUPS
      // Server-side enforcement would require a read operation which is expensive
      // Client validates the limit before allowing group creation
      allow create: if request.auth != null;

      // Helper: Is user joining the group (adding themselves to members)?
      // Used for share code joining where non-members can add themselves
      function isUserJoining() {
        let oldMembers = resource.data.members;
        let newMembers = request.resource.data.members;
        let userId = request.auth.uid;

        // User must not already be a member
        // User must be adding only themselves to members array
        // Members array must grow by exactly 1
        return !(userId in oldMembers)
            && userId in newMembers
            && newMembers.size() == oldMembers.size() + 1;
      }

      // Helper: Is user leaving the group (removing themselves from members)?
      // Story 14d-v2-1-7a: Allow members to remove themselves from groups
      // ECC Review: Security fix - members must be able to leave
      function isUserLeaving() {
        let oldMembers = resource.data.members;
        let newMembers = request.resource.data.members;
        let userId = request.auth.uid;

        // User must be a current member
        // User must be removing only themselves
        // Members array must shrink by exactly 1
        // Owner cannot use the leave path (must transfer/delete instead)
        // Only members array and updatedAt can change
        return userId in oldMembers
            && !(userId in newMembers)
            && newMembers.size() == oldMembers.size() - 1
            && resource.data.ownerId != userId
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'updatedAt']);
      }

      // Update: Owner can update group settings, member can join, or member can leave
      // AC#4: Non-owners cannot update (except to join or leave)
      // Story 14d-v2-1-6c-2: Allow joining via share code
      // Story 14d-v2-1-7a: Allow members to leave group
      // Story 14d-v2-1-11b: Transaction sharing toggle fields (owner-only via isGroupOwner)
      //   - transactionSharingEnabled (AC6)
      //   - transactionSharingLastToggleAt (AC7)
      //   - transactionSharingToggleCountToday (AC8)
      //   - transactionSharingToggleCountResetAt
      //   Non-owners denied write (AC9) - enforced by isGroupOwner() check
      allow update: if isGroupOwner() || (request.auth != null && isUserJoining()) || (request.auth != null && isUserLeaving());

      // Delete: Only owner can delete group
      // AC#4: Non-owners cannot delete
      allow delete: if isGroupOwner();

      // ========================================================================
      // Changelog Subcollection - Epic 14d-v2 Story 1.3b
      // Append-only changelog for transaction sync between group members
      // TTL: 30 days (AD-9) - configured via Firebase Console
      // ========================================================================
      match /changelog/{changeId} {
        // Helper: Validate changelog entry structure
        // Note: Cloud Functions using Admin SDK bypass security rules entirely,
        // so actorId == auth.uid is safe to enforce for client-side writes
        function isValidChangelogEntry() {
          let entry = request.resource.data;
          return entry.type in ['TRANSACTION_ADDED', 'TRANSACTION_MODIFIED', 'TRANSACTION_REMOVED']
              && entry.transactionId is string
              && entry.transactionId.size() > 0
              && entry.actorId == request.auth.uid
              && entry.groupId is string
              && entry.groupId == groupId
              && entry.timestamp is timestamp
              && entry._ttl is timestamp
              && entry.summary is map
              && entry.summary.amount is number
              && entry.summary.currency is string
              && entry.summary.description is string;
        }

        // Read: Group members only
        allow read: if isGroupMemberForSubcollection();

        // Create: Group members only with validation
        allow create: if isGroupMemberForSubcollection() && isValidChangelogEntry();

        // Update/Delete: FORBIDDEN (append-only pattern)
        allow update, delete: if false;
      }
    }

    // ============================================================================
    // Pending Invitations - Epic 14d-v2 Story 1.5b-2, 1.6e
    // Invitations for joining shared groups
    // Status can be updated by invited user (accept/decline)
    // ============================================================================
    match /pendingInvitations/{invitationId} {
      // Helper: Check if user is the owner of the group referenced in the invitation
      // For create: uses request.resource.data (new document)
      // For delete: uses resource.data (existing document)
      function isGroupOwnerForInvitation(groupId) {
        return exists(/databases/$(database)/documents/sharedGroups/$(groupId))
            && get(/databases/$(database)/documents/sharedGroups/$(groupId)).data.ownerId == request.auth.uid;
      }

      // Helper: Check if this is a valid status update (accept/decline)
      // Story 14d-v2-1-6e: Task 11.1-11.3
      // Allows: authenticated user whose email matches the invited email
      // Only: changing status from 'pending' to 'accepted' or 'declined'
      function isValidStatusUpdate() {
        // Must be authenticated
        // Email must match (case-insensitive via normalized storage)
        // Current status must be 'pending'
        // New status must be terminal ('accepted' or 'declined')
        // Only the status field can be changed
        return request.auth != null
            && resource.data.invitedEmail == request.auth.token.email
            && resource.data.status == 'pending'
            && request.resource.data.status in ['accepted', 'declined']
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
      }

      // Create: Only authenticated group owners can create invitations (AC #3)
      // Verifies the group exists and the creator is the group owner
      allow create: if request.auth != null
        && request.resource.data.groupId is string
        && isGroupOwnerForInvitation(request.resource.data.groupId);

      // Read: Any authenticated user can read invitations (AC #3)
      // This allows users to see invitations sent to their email
      allow read: if request.auth != null;

      // Update: Only invited user can accept/decline (Story 14d-v2-1-6e AC #1)
      // Validates: email matches, status is pending, new status is terminal
      allow update: if isValidStatusUpdate();

      // Delete: Only group owner can delete/cancel invitations (AC #3)
      allow delete: if request.auth != null
        && resource.data.groupId is string
        && isGroupOwnerForInvitation(resource.data.groupId);
    }

    // ============================================================================
    // Default Deny - All other paths
    // ============================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
