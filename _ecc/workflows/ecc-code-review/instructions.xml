<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>ECC ADAPTIVE CODE REVIEW - Orchestrator selects and spawns agents based on story complexity</critical>
  <critical>Use a SINGLE message with MULTIPLE Task calls for true parallelism</critical>

  <!-- AUTO-PROCEED: This workflow runs non-interactively between steps.
       Do NOT ask "Continue to next step?" or pause for confirmation.
       ONLY pause at Step 4 (triage choice) and Step 6e (E2E gap action).
       All other steps execute automatically in sequence. -->
  <critical>AUTO-PROCEED MODE: Skip all generic "Continue?" confirmations.
    Only pause at Step 4 triage and Step 6e E2E gap. All other steps auto-proceed.</critical>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 0: Project Knowledge Loading                                       -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="0" goal="Load project knowledge for ECC review agents" tag="knowledge-init">
    <critical>üìö Load project patterns ONCE for all review agents</critical>

    <action>Load {project-root}/_ecc/knowledge/code-review-patterns.md ‚Üí {{cached_review_patterns}}</action>
    <action>Load {project-root}/docs/architecture/firestore-patterns.md ‚Üí {{cached_firestore}}</action>
    <action>Load {project-root}/docs/architecture/state-management.md ‚Üí {{cached_state_mgmt}}</action>
    <action>Load {project-root}/docs/architecture/component-patterns.md ‚Üí {{cached_components}}</action>
    <action>Load .claude/rules/testing.md ‚Üí {{cached_testing_guidelines}}</action>
    <action>Store combined as {{project_patterns}} for ECC agents</action>
    <action>Store testing content as {{project_testing_patterns}} for TDD Guide</action>

    <output>üìö **ECC Orchestrator Initialized for Parallel Review**

      Project knowledge loaded for review agents:
      - Code review patterns (MUST CHECK): {{review_patterns_summary}}
      - Firestore patterns: {{firestore_summary}}
      - State management: {{state_mgmt_summary}}
      - Component patterns: {{components_summary}}
      - Testing guidelines: {{testing_summary}}

      Ready to spawn parallel review team.
    </output>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 1: Load Story and Discover Changes                                 -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="1" goal="Load story and discover files to review">
    <action>Use provided {{story_path}} or ask user which story to review</action>
    <action>Read COMPLETE story file</action>
    <action>Extract {{story_key}} from filename</action>
    <action>Extract {{epic_id}} from {{story_key}} (e.g., "14d-v2-1-13" ‚Üí epic_id = "14d-v2")</action>
    <action>Parse sections: Acceptance Criteria, Tasks, File List</action>

    <!-- ARCHITECTURE ENFORCEMENT: Extract architectural ACs -->
    <critical>üèóÔ∏è ARCHITECTURE ENFORCEMENT: Extract architectural ACs for validation</critical>
    <action>Parse "Architectural Acceptance Criteria" section from story</action>
    <action>Extract {{architectural_acs}} - all architectural ACs</action>
    <action>Extract {{file_specification_table}} from "File Specification" section</action>
    <action>Identify {{feature_name}} from story context</action>

    <action>Extract {{architecture_reference}} - source of architectural patterns</action>

    <check if="architectural ACs found">
      <output>üèóÔ∏è **Architectural ACs Loaded for Review**

        **Architecture Source:** {{architecture_reference}}

        - File Location ACs: {{file_location_ac_count}}
        - Pattern ACs: {{pattern_ac_count}}
        - Anti-Pattern ACs: {{antipattern_ac_count}}

        Architecture agent will validate against documented patterns.
      </output>
    </check>

    <check if="NO architectural ACs found">
      <action>Set {{architectural_acs}} = "No architectural ACs specified in story"</action>
      <output>‚ö†Ô∏è **Warning: No Architectural ACs in Story**

        This story lacks architectural acceptance criteria from documented architecture.
        Architecture review will flag any obvious pattern violations but cannot
        validate against specific documented patterns.

        **Recommendation:** Re-create story using `ecc-create-story` to generate
        ACs from architecture documentation.
      </output>
    </check>

    <!-- Git discovery -->
    <check if="git repository exists">
      <action>Run `git status --porcelain` to find uncommitted changes</action>
      <action>Run `git diff --name-only` to see modified files</action>
      <action>Compile {{files_to_review}} as a FILE PATH LIST from git + story File List</action>
    </check>

    <!-- CONTEXT BUDGET: Read files ONCE here, pass to agents (avoids 4x duplication) -->
    <critical>Read ALL files in {{files_to_review}} NOW using parallel Read calls.
      Store as {{file_contents_manifest}} ‚Äî each file's path and full content.
      Agents will receive this content in their prompts and MUST NOT read files themselves.
      This avoids each agent independently reading the same files (4x cost savings).</critical>
    <action>Read all {{files_to_review}} in parallel (use multiple Read tool calls in one message)</action>
    <action>Store combined content as {{file_contents_manifest}}</action>

    <output>üìã **Review Target Identified**

      Story: {{story_key}}
      Files to review: {{file_count}}
      Functional ACs to validate: {{functional_ac_count}}
      Architectural ACs to validate: {{arch_ac_count}}
    </output>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 1.5: Adaptive Story Classification                                  -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="1.5" goal="Classify story complexity for adaptive review agent selection" tag="classification">
    <critical>üéØ ADAPTIVE REVIEW: Select appropriate review agents based on story complexity</critical>
    <critical>Not every story needs 4 agents ‚Äî TRIVIAL stories get code-reviewer only</critical>

    <!-- Parse story metrics -->
    <action>Parse metrics from story file and {{files_to_review}}:
      - {{task_count}}: Number of top-level tasks (checked + unchecked)
      - {{subtask_count}}: Total subtasks across all tasks
      - {{file_count}}: Number of files in File List / git diff
      - {{file_paths}}: List of all file paths
    </action>

    <!-- Check for security-sensitive files -->
    <action>Check if any {{file_paths}} match security patterns:
      - "firestore.rules"
      - "**/security/**"
      - "**/functions/**"
      - "**/auth/**"
    </action>
    <action>Set {{has_security_files}} = true/false</action>

    <!-- Check for architecture-sensitive files -->
    <action>Check if any {{file_paths}} match architecture patterns:
      - "**/stores/**"
      - "**/contexts/**"
      - "**/features/**/index.ts"
      - "**/*.types.ts"
    </action>
    <action>Set {{has_architecture_files}} = true/false</action>

    <!-- Check for security keywords in story content -->
    <action>Search story content for keywords: authentication, authorization, delete, cascade, password, token, secret</action>
    <action>Set {{has_security_keywords}} = true/false</action>

    <!-- Classification logic (cascade ‚Äî first match wins, then force-includes adjust) -->
    <classification>
      <check if="task_count > 6 OR file_count > 10 OR ({{has_architecture_files}} AND {{has_security_files}})">
        <action>Set {{classification}} = "COMPLEX"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer", "architect", "tdd-guide"]</action>
      </check>

      <check if="{{classification}} is NOT set AND (task_count > 4 OR file_count > 6 OR {{has_security_files}} OR {{has_security_keywords}})">
        <action>Set {{classification}} = "STANDARD"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "security-reviewer"]</action>
      </check>

      <check if="{{classification}} is NOT set AND task_count &lt;= 2 AND subtask_count &lt;= 5 AND file_count &lt;= 3 AND NOT {{has_security_files}}">
        <action>Set {{classification}} = "TRIVIAL"</action>
        <action>Set {{review_agents}} = ["code-reviewer"]</action>
      </check>

      <check if="{{classification}} is NOT set AND task_count &lt;= 4 AND subtask_count &lt;= 12 AND file_count &lt;= 6">
        <action>Set {{classification}} = "SIMPLE"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "tdd-guide"]</action>
      </check>

      <check if="{{classification}} is NOT set">
        <action>Set {{classification}} = "SIMPLE"</action>
        <action>Set {{review_agents}} = ["code-reviewer", "tdd-guide"]</action>
      </check>
    </classification>

    <!-- Force-include agents based on file sensitivity -->
    <check if="{{has_security_files}} OR {{has_security_keywords}}">
      <action>Force add "security-reviewer" to {{review_agents}} if not already present</action>
    </check>
    <check if="{{has_architecture_files}} AND task_count > 6">
      <action>Force add "architect" to {{review_agents}} if not already present</action>
    </check>

    <output>üéØ **Adaptive Review Classification**

      **Story:** {{story_key}}
      **Classification:** {{classification}}

      **Metrics:**
      - Tasks: {{task_count}}
      - Subtasks: {{subtask_count}}
      - Files: {{file_count}}

      **Sensitivity Flags:**
      - Security-sensitive files: {{has_security_files}}
      - Architecture-sensitive files: {{has_architecture_files}}
      - Security keywords in story: {{has_security_keywords}}

      **Selected Review Agents ({{agent_count}}):** {{review_agents}}
    </output>

    <!-- CONTEXT BUDGET: Large story warning -->
    <check if="file_count > 12">
      <output>**Context Budget Warning:** {{file_count}} files exceeds the 12-file story
        sizing guideline. This review may exhaust context if all agents produce
        detailed findings. Consider:
        1. Splitting the story via `/story-sizing` before review
        2. Running only 2 agents (e.g., code-reviewer + tdd-guide) then a second
           pass with (security-reviewer + architect)
        3. Proceeding as-is but with strict compact output mode</output>
    </check>

    <!-- Auto-proceed: classification displayed above, no confirmation needed -->
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 2: ADAPTIVE ECC REVIEW - Spawn Selected Agents                     -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="2" goal="Spawn selected ECC agents based on adaptive classification">
    <critical>ECC ORCHESTRATOR: Spawning ONLY agents from {{review_agents}} ({{classification}} classification)</critical>
    <critical>CRITICAL: Send ALL selected Task calls in a SINGLE message for true parallelism!</critical>

    <parallel-execution-rule>
      HOW TO ACHIEVE TRUE PARALLELISM:

      You MUST issue ALL selected agent Task calls in your NEXT SINGLE RESPONSE.
      Only spawn agents listed in {{review_agents}} ‚Äî skip the rest.
    </parallel-execution-rule>

    <output>**Spawning {{classification}} Review Team...**

      **Classification:** {{classification}}
      **Agents launching:** {{review_agents}}
    </output>

    <!-- ADAPTIVE PARALLEL SPAWN - Only selected agents, ALL IN ONE MESSAGE -->
    <!-- All agent prompts include file contents and compact output directive -->
    <agent-directives>
      IMPORTANT ‚Äî include these directives in EVERY agent prompt:
      1. File contents are provided below. Do NOT use Read/Grep/Glob to read review files.
      2. Return ONLY: numbered findings table (severity | description | file:line), recommendation (APPROVE / CHANGES REQUESTED / BLOCKED), score (X/10). Max ~50 lines. No code snippets or lengthy reasoning.
    </agent-directives>

    <ecc-parallel-spawn agents="{{review_agents}}">
      <!-- Task 1: Code Reviewer (ALWAYS included) -->
      <task-call id="code_review" if="code-reviewer in {{review_agents}}">
        subagent_type: "everything-claude-code:code-reviewer"
        model: "sonnet"
        max_turns: 5
        description: "Code quality review for {{story_key}}"
        prompt: |
          ## Code Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Acceptance Criteria:** {{acceptance_criteria}}
          **Project Patterns:** {{project_patterns}}

          **Review:** quality, error handling, performance, naming, DRY, complexity

          **Output (max 50 lines):**
          | # | Sev | Finding | file:line |
          Recommendation: APPROVE / CHANGES REQUESTED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>

      <!-- Task 2: Security Reviewer (STANDARD + COMPLEX only) -->
      <task-call id="security_review" if="security-reviewer in {{review_agents}}">
        subagent_type: "everything-claude-code:security-reviewer"
        model: "sonnet"
        max_turns: 5
        description: "Security review for {{story_key}}"
        prompt: |
          ## Security Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Check:** OWASP Top 10 (injection, XSS, auth, access control, secrets, data exposure, CSRF, input validation)

          **Output (max 50 lines):**
          | # | Sev | Vulnerability | file:line | Remediation |
          Secrets detected: Y/N
          Recommendation: APPROVE / BLOCK / CHANGES REQUESTED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>

      <!-- Task 3: Architect (COMPLEX only) -->
      <task-call id="architecture_review" if="architect in {{review_agents}}">
        subagent_type: "everything-claude-code:architect"
        model: "opus"
        max_turns: 5
        description: "Architecture review for {{story_key}}"
        prompt: |
          ## Architecture Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Architecture Source:** {{architecture_reference}}
          **Architectural ACs:** {{architectural_acs}}
          **File Specification:** {{file_specification_table}}
          **Patterns:** {{project_patterns}}

          **Validate:** file locations, pattern compliance, anti-patterns, architectural ACs, separation of concerns, dependency management, layer violations, coupling

          **Output (max 50 lines):**
          | AC ID | Status | Notes |
          File location compliance: X/Y
          Pattern violations: [list or none]
          Anti-patterns: [list or none]
          Alignment: ALIGNED / DRIFT DETECTED
          Recommendation: APPROVE / CHANGES REQUESTED / BLOCKED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>

      <!-- Task 4: TDD Guide (SIMPLE + COMPLEX only) -->
      <task-call id="test_review" if="tdd-guide in {{review_agents}}">
        subagent_type: "everything-claude-code:tdd-guide"
        model: "haiku"
        max_turns: 5
        description: "Test review for {{story_key}}"
        prompt: |
          ## Test Coverage Review Task
          **Story:** {{story_key}}
          **IMPORTANT: File contents provided below. Do NOT read files yourself.**

          **Acceptance Criteria:** {{acceptance_criteria}}
          **Testing Patterns:** {{project_testing_patterns}}

          **Review:** AC coverage, edge cases, error scenarios, assertion quality, mock appropriateness, naming

          **TEA Score (each 0-100):** Determinism, Isolation, Maintainability, Coverage, Performance. 70+ = GOOD.

          **Output (max 50 lines):**
          Coverage gaps: [AC] missing test for [scenario] [file]
          Quality issues: [test] [issue] [file:line]
          | Dimension | Score | Notes |
          Overall: X/100 ‚Äî GOOD / NEEDS IMPROVEMENT
          Recommendation: APPROVE / CHANGES REQUESTED
          Score: X/10

          ---
          **FILE CONTENTS:**
          {{file_contents_manifest}}
      </task-call>
    </ecc-parallel-spawn>

    <action>Wait for all selected agents to complete</action>
    <action>Collect outputs ‚Äî extract ONLY: finding #, severity, agent, one-line description, file:line</action>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 3: Review Synthesis - Merge and Analyze                             -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="3" goal="Synthesis of parallel review outputs">
    <critical>üó∫Ô∏è REVIEW SYNTHESIS - Merge findings, resolve conflicts, add workflow analysis</critical>
    <critical>üèóÔ∏è ARCHITECTURE GATE: Architectural violations are BLOCKING</critical>
    <critical>üìä WEIGHTED SCORING: Adjust weights based on which agents were used</critical>

    <action>Merge findings from all spawned agents ({{review_agents}}) by severity:
      - CRITICAL: Security vulnerabilities requiring immediate fix
      - HIGH: Must fix before approval (includes architectural violations)
      - MEDIUM: Should fix, can be action items
      - LOW: Nice to have improvements
    </action>

    <action>Identify conflicts between agent recommendations</action>
    <action>Add cross-cutting impact analysis:
      - Check if {{files_to_review}} span multiple src/features/ directories
      - If cross-feature changes detected, recommend: "Run `/ecc-impact-analysis {{story_key}}` to assess full blast radius"
      - Note any shared services/types modified that may affect other features
    </action>

    <!-- Scoring: average of active agent scores -->
    <action>Calculate individual agent scores (1-10 scale) for each spawned agent</action>
    <action>Calculate overall score as average of all active agent scores</action>

    <!-- ARCHITECTURE ENFORCEMENT: Highlight architectural findings -->
    <action>Extract architectural findings from architect review:
      - FSD compliance status
      - Zustand compliance status
      - Architectural AC validation results
    </action>

    <output>## üó∫Ô∏è ECC Adaptive Review Synthesis

      **Story:** {{story_key}} | **Date:** {date} | **Classification:** {{classification}} | **Agents:** {{review_agents}}

      ---

      ### üìä Overall Assessment

      | Agent | Score | Status |
      |-------|-------|--------|
      | Code Quality | {{code_score}}/10 | {{code_status}} |
      {{#if security-reviewer in review_agents}}
      | Security | {{security_score}}/10 | {{security_status}} |
      {{/if}}
      {{#if architect in review_agents}}
      | Architecture | {{arch_score}}/10 | {{arch_status}} |
      {{/if}}
      {{#if tdd-guide in review_agents}}
      | Testing | {{test_score}}/10 | {{test_status}} |
      {{/if}}
      | **OVERALL** | **{{overall_score}}/10** | **{{overall_status}}** |

      {{#if architectural_violations}}
      ‚ö†Ô∏è **ARCHITECTURAL VIOLATIONS (blocks approval):**
      {{architectural_violations}}
      {{/if}}

      ---

      ### üìã Numbered Findings

      Each finding is auto-classified: ‚ö° **QUICK** (fix now) or üîß **COMPLEX** (needs separate work)

      | # | Sev | Agent | Finding | Effort |
      |---|-----|-------|---------|--------|
      {{#each all_findings_numbered}}
      | {{index}} | {{severity}} | {{agent}} | {{description}} [{{file}}:{{line}}] | {{effort_class}} |
      {{/each}}

      ---

      **Recommendation:** {{final_recommendation}}
    </output>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 4: Smart Triage - Classify, Choose, Execute                        -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="4" goal="Auto-triage findings by effort, let user choose handling per item or batch">
    <critical>üéØ SMART TRIAGE: Every finding gets an effort classification + suggested action</critical>
    <critical>Goal: Always fix the easy wins NOW, give user control over what to defer</critical>

    <!-- ‚îÄ‚îÄ‚îÄ 4a: Auto-classify each finding by effort ‚îÄ‚îÄ‚îÄ -->
    <action>For each finding from Step 3, classify effort:

      ‚ö° QUICK (fix in current session) ‚Äî criteria:
      - Missing validation or guard clause (1-5 lines)
      - Naming convention fix
      - Missing error handling on a single call
      - Adding a missing test assertion
      - Import cleanup or unused variable
      - Simple type fix
      - Missing null check
      - Documentation/comment fix
      - Single-file, localized change

      üîß COMPLEX (needs separate work) ‚Äî criteria:
      - Multi-file refactoring
      - New abstraction or pattern introduction
      - Architectural restructuring
      - Service layer redesign
      - New test infrastructure needed
      - Security model change
      - State management refactoring
      - Performance optimization requiring profiling
      - Changes touching >3 files
    </action>

    <action>Build {{numbered_findings}} list:
      For each finding assign:
      - {{index}}: sequential number (1, 2, 3...)
      - {{severity}}: CRITICAL / HIGH / MEDIUM / LOW
      - {{agent}}: which ECC agent found it
      - {{description}}: one-line summary
      - {{file}}: file path and line
      - {{effort_class}}: ‚ö° QUICK or üîß COMPLEX
      - {{suggested_action}}: FIX_NOW (for QUICK) or DEFER (for COMPLEX)
    </action>

    <action>Count totals:
      - {{quick_count}} = findings classified as ‚ö° QUICK
      - {{complex_count}} = findings classified as üîß COMPLEX
      - {{total_findings}} = quick_count + complex_count
    </action>

    <!-- ‚îÄ‚îÄ‚îÄ 4b: Present triage options ‚îÄ‚îÄ‚îÄ -->
    <ask>**Smart Triage** ‚Äî {{quick_count}} quick fixes, {{complex_count}} complex items

      1. **[Q]uick + Defer** ‚Äî Fix all ‚ö° QUICK now ‚Üí create TD stories for üîß COMPLEX *(Recommended)*
      2. **[F]ix all** ‚Äî Fix everything now (only if scope fits in session)
      3. **[C]ustom** ‚Äî Per-item control with range syntax (e.g., `fix 1-3, defer 4-6`)
      4. **[S]kip** ‚Äî Mark review complete without changes

      Choose [Q], [F], [C], or [S]:</ask>

    <!-- ‚îÄ‚îÄ‚îÄ 4c: Execute chosen triage strategy ‚îÄ‚îÄ‚îÄ -->

    <check if="user chooses Q (Quick + Defer)">
      <action>Fix all findings where effort_class = ‚ö° QUICK</action>
      <action>Re-run tests after fixes</action>
      <action>Set {{fixed_items}} = list of fixed finding indices</action>
      <action>Set {{fixed_count}} = number of QUICK items fixed</action>
      <action>Set {{td_items}} = all findings where effort_class = üîß COMPLEX</action>
      <action>Proceed to Step 4.5 with {{td_items}} ‚Äî TD stories WILL be created</action>
    </check>

    <check if="user chooses F (Fix all)">
      <action>Fix ALL findings (both QUICK and COMPLEX)</action>
      <action>Re-run tests after fixes</action>
      <action>Update File List in story</action>
      <action>Set {{fixed_count}} = total_findings</action>
    </check>

    <check if="user chooses C (Custom)">
      <ask>Enter triage commands using range syntax:

        - `fix 1-5` or `fix 1,3,5` ‚Äî fix these items now
        - `defer 6-8` ‚Äî create TD stories for these items
        - Combine: `fix 1-3, defer 4-6`
        - Shortcuts: `fix quick`, `defer complex`

        Every `defer` item WILL become a tracked TD story.

        Enter triage commands:</ask>

      <action>Parse user's triage commands:
        - Extract ranges: "1-5" ‚Üí [1,2,3,4,5]
        - Extract lists: "1,3,5" ‚Üí [1,3,5]
        - Extract keywords: "quick" ‚Üí all QUICK indices, "complex" ‚Üí all COMPLEX indices
        - Map each finding index to: FIX or DEFER
      </action>

      <action>Fix all findings assigned to FIX</action>
      <action>Re-run tests after fixes</action>
      <action>Set {{fixed_items}} = list of FIX indices</action>
      <action>Set {{fixed_count}} = count of FIX items</action>

      <check if="any findings assigned to DEFER">
        <action>Set {{td_items}} = all findings assigned to DEFER</action>
        <action>Proceed to Step 4.5 with {{td_items}} ‚Äî TD stories WILL be created</action>
      </check>

      <output>‚úÖ **Custom Triage Complete**

        - ‚ö° Fixed now: {{fixed_count}} items ({{fixed_items}})
        {{#if td_items}}
        - üóÇÔ∏è Deferred: {{td_item_count}} items ‚Üí creating TD stories...
        {{/if}}
      </output>
    </check>

    <check if="user chooses S (Skip)">
      <output>‚è≠Ô∏è Review marked complete without changes.</output>
    </check>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 4.5: Deferred Item Audit + Tech Debt Story Creation (MANDATORY)    -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="4.5" goal="Audit ALL deferred items and ensure every one is tracked by a story">
    <critical>üóÇÔ∏è TECH DEBT TRACKING - Every deferred item MUST be tracked by a story</critical>
    <critical>NO dark void ‚Äî deferred items ALWAYS get stories + sprint-status updates</critical>
    <critical>This step is MANDATORY even when Step 4 triage has zero deferred items</critical>

    <!-- ‚îÄ‚îÄ‚îÄ 4.5a: Collect ALL deferred items from ALL sources ‚îÄ‚îÄ‚îÄ -->
    <action>Build {{all_deferred_items}} by collecting from THREE sources:

      **Source 1: Triage deferrals** (from Step 4)
      - Use {{td_items}} from Step 4 (items user chose to defer during triage)

      **Source 2: Story pre-existing deferrals**
      - Search the story's Dev Notes for: "Deferred", "out of scope", "follow-up", "future"
      - These are items deferred BEFORE this review (e.g., during dev-story)
      - Add each to {{all_deferred_items}}

      **Source 3: Agent out-of-scope findings**
      - Search agent review outputs for items flagged as:
        "out of scope", "pre-existing", "not part of this story", "follow-up recommended"
      - These are issues agents found but noted as beyond this story's scope
      - Add each to {{all_deferred_items}}
    </action>

    <!-- ‚îÄ‚îÄ‚îÄ 4.5b: Verify existing coverage for each deferred item ‚îÄ‚îÄ‚îÄ -->
    <action>For EACH item in {{all_deferred_items}}, check if already tracked:

      1. Search {sprint_artifacts}/stories/ for story files covering this item
         - Grep for the function name, file name, or pattern described
      2. Search {sprint_status} for any story whose description matches
      3. Check if the item is explicitly listed as a task/AC in an existing story

      Set {{item.tracked}} = true/false for each item
      Set {{item.tracking_story}} = story ID if tracked
    </action>

    <!-- ‚îÄ‚îÄ‚îÄ 4.5c: Handle tracked items ‚Äî verify + link ‚îÄ‚îÄ‚îÄ -->
    <check if="any items have {{item.tracked}} = true">
      <action>For each tracked item:
        - Verify the tracking story actually covers the deferred work (not just mentions it)
        - Update the source story's deferred reference to link to the tracking story
          e.g., "Deferred: X ‚Äî tracked in [15-TD-Y](./15-TD-Y-slug.md)"
      </action>
    </check>

    <!-- ‚îÄ‚îÄ‚îÄ 4.5d: Handle untracked items ‚Äî create stories or add to existing ‚îÄ‚îÄ‚îÄ -->
    <check if="any items have {{item.tracked}} = false">
      <action>For each UNTRACKED item, decide:

        **Option A: Add to existing story** ‚Äî if an existing ready-for-dev story covers a related theme
        - Add as new Task/AC to that story
        - Update File Specification table if new files affected
        - Note: "Added from {{story_key}} code review ({{date}})"

        **Option B: Create new TD story** ‚Äî if no existing story covers this theme
        - Group related untracked items into a single story (minimize story count)
        - Use TD story template (below)
      </action>

      <!-- Create new TD stories when needed -->
      <action>For each new TD story group, create story using template:

        ```markdown
        # Tech Debt Story TD-{{epic_id}}-{{td_number}}: {{title}}

        Status: ready-for-dev

        > **Source:** ECC Code Review ({{date}}) on story {{story_key}}
        > **Priority:** {{priority}}
        > **Estimated Effort:** {{effort_estimate}}

        ## Story

        As a **developer**,
        I want **{{what}}**,
        So that **{{why}}**.

        ## Acceptance Criteria

        {{acceptance_criteria}}

        ## Tasks / Subtasks

        {{tasks}}

        ## Dev Notes

        - Source story: [{{story_key}}](./{{story_filename}})
        - Review findings: {{finding_indices}}
        - Files affected: {{affected_files}}
        ```
      </action>

      <action>Write story files to: {sprint_artifacts}/stories/TD-{{epic_id}}-{{td_number}}-{{slug}}.md</action>
    </check>

    <!-- ‚îÄ‚îÄ‚îÄ 4.5e: Update sprint-status.yaml + source story (MANDATORY) ‚îÄ‚îÄ‚îÄ -->
    <action>For each NEW TD story created:
      - Add to sprint-status.yaml with status: ready-for-dev
      - Add DEPENDS: {{story_key}} (source story)
    </action>

    <action>Update source story {{story_key}} with tracking table:
      ```markdown
      ### Tech Debt Stories Created / Updated

      | TD Story | Description | Priority | Action |
      |----------|-------------|----------|--------|
      {{#each all_resolved_items}}
      | [{{tracking_id}}](./{{filename}}) | {{description}} | {{priority}} | {{action}} |
      {{/each}}
      ```
      Where {{action}} is one of: CREATED, ADDED_TO_EXISTING, ALREADY_TRACKED
    </action>

    <!-- ‚îÄ‚îÄ‚îÄ 4.5f: Summary output ‚îÄ‚îÄ‚îÄ -->
    <output>üóÇÔ∏è **Deferred Item Audit Complete**

      **Sources scanned:**
      - Triage deferrals: {{triage_deferred_count}}
      - Story pre-existing deferrals: {{preexisting_deferred_count}}
      - Agent out-of-scope findings: {{agent_deferred_count}}

      **Resolution:**
      - Already tracked by existing stories: {{already_tracked_count}}
      - Added to existing stories: {{added_to_existing_count}}
      - New TD stories created: {{new_td_count}}
      - Total deferred items verified: {{total_deferred}}

      {{#if new_td_count > 0}}
      **New TD stories:**
      {{#each new_td_stories}}
      - **{{id}}**: {{title}} ({{priority}}) ‚Üí `{{filepath}}`
      {{/each}}
      {{/if}}

      {{#if added_to_existing_count > 0}}
      **Added to existing stories:**
      {{#each added_to_existing}}
      - **{{item}}** ‚Üí added to {{tracking_story}}
      {{/each}}
      {{/if}}

      Sprint status updated. All deferred items are now tracked.
    </output>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 5: Cost Tracking + E2E Coverage Check                              -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="5" goal="Cost tracking, E2E coverage, and Firebase analysis before status update">

    <!-- 5a: Quick check for UI changes -->
    <action>Check if any {{files_to_review}} match UI patterns:
      "src/components/**/*.tsx" (excluding ui/), "src/hooks/*.ts", "src/stores/*.ts"</action>
    <action>Set {{has_ui_changes}} = true/false</action>

    <check if="{{has_ui_changes}}">
      <!-- 5b: Search existing E2E specs for coverage of changed UI -->
      <action>Extract data-testid values from changed .tsx files, search tests/e2e/*.spec.ts for coverage</action>
      <action>Set {{uncovered_testids}} and {{ui_missing_e2e}}</action>

      <!-- 5c: Critical path assessment -->
      <action>Check if changes are on critical user path (auth, canvas, toolbox, inspector, YAML import/export)</action>
    </check>

    <!-- MANDATORY: Check for Firebase backend changes that need separate deployment -->
    <action>Check if any {{files_to_review}} match Firebase backend patterns:
      - "firestore.rules" ‚Üí needs `firebase deploy --only firestore:rules`
      - "firestore.indexes.json" ‚Üí needs `firebase deploy --only firestore:indexes`
      - "storage.rules" ‚Üí needs `firebase deploy --only storage`
      - "functions/src/**" ‚Üí needs `cd functions && npm run build && firebase deploy --only functions`
    </action>
    <action>Set {{has_firebase_backend_changes}} = true/false</action>
    <action>Set {{firebase_deploy_targets}} = comma-separated list of targets (e.g., "firestore:rules,firestore:indexes")</action>

    <!-- MANDATORY: Cost tracking runs BEFORE story status update so it never gets skipped -->
    <critical>You MUST execute this bash command and capture its output. Do NOT skip it. Do NOT generate the final output without running this command first.</critical>
    <action>Run cost analyzer: `workflow-cost --csv --stats --workflow "ecc-code-review" --story "{{story_key}}"`</action>
    <action>Store the FULL terminal output as {{cost_report_output}} ‚Äî include the COST NOTICE box</action>

    <!-- MANDATORY: Build commit commands for the user -->
    <action>Build list of {{review_changed_files}} ‚Äî files modified/created during THIS review session:
      - Story file (status update + review summary)
      - sprint-status.yaml (status change + any new TD entries)
      - Any new TD story files created in Step 4.5
      - Any source/test files modified by quick fixes in Step 4
    </action>

    <output>‚úÖ **Cost & E2E Analysis Complete** ‚Äî proceeding to story status update.</output>
  </step>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STEP 6: Story Status Update + Review Complete (MUST be last step)       -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <step n="6" goal="Update story status and present final review summary">
    <critical>Story status update is the FINAL step. Cost tracking and E2E analysis already ran in Step 5.</critical>

    <check if="no CRITICAL or HIGH issues OR all fixed">
      <action>Update story Status to "done"</action>
      <action>Set {{new_status}} = "done"</action>
    </check>

    <check if="CRITICAL or HIGH issues remain">
      <action>Update story Status to "in-progress"</action>
      <action>Set {{new_status}} = "in-progress"</action>
    </check>

    <check if="{{sprint_status}} file exists">
      <action>Update sprint-status.yaml: {{story_key}} ‚Üí {{new_status}}</action>
    </check>

    <action>Add "Senior Developer Review (ECC)" section to story with:
      - Review date
      - ECC agents used
      - Outcome
      - Action items count
    </action>

    <!-- Final unified output with cost, commit commands, and next steps -->
    <output>**ECC Code Review Complete!**

      **Story:** {{story_key}} | **Status:** {{new_status}} | **Classification:** {{classification}}
      **Triage:** {{fixed_count}} fixed, {{td_story_count}} TD stories
      **Agents:** {{review_agents}}

      {{#if has_ui_changes}}
      {{#if ui_missing_e2e}}
      **E2E:** gaps detected for {{uncovered_testids}}
      **Critical path:** {{is_critical_path}} ‚Äî {{critical_path_reason}}
      {{/if}}
      {{#if NOT ui_missing_e2e}}
      **E2E:** Existing specs cover changed UI components.
      {{/if}}
      {{/if}}
      {{#if NOT has_ui_changes}}
      **E2E:** No UI changes ‚Äî E2E check skipped.
      {{/if}}

      {{#if has_firebase_backend_changes}}
      **Firebase Backend Changes Detected:**
      This story modifies Firebase backend files that do NOT auto-deploy with Hosting.
      When deploying, you MUST run `firebase deploy --only {{firebase_deploy_targets}}` separately.
      The `/deploy-story` workflow handles this automatically (Step 5).
      {{/if}}

      **Session Cost:**
      {{cost_report_output}}

      ---

      **Commit Commands (copy-paste):**

      ```bash
      # Stage review artifacts
      {{#each review_changed_files}}
      git add {{file_path}}
      {{/each}}

      # Commit
      git commit -m "$(cat &lt;&lt;'EOF'
      Review {{story_key}}: {{overall_status}} {{overall_score}}/10{{#if td_story_count}}, create {{td_stories_list}}{{/if}}

      Co-Authored-By: Claude Opus 4.6 &lt;noreply@anthropic.com&gt;
      EOF
      )"
      ```

      **Next Steps:**
      - Run `/workflow-close` to verify tests, status files, and branch state
      {{#if new_status == "done"}}
      - Run `/deploy-story` to deploy ‚Äî or [C]ommit to branch for batching multiple stories
      {{/if}}
      {{#if has_ui_changes}}
      {{#if ui_missing_e2e}}
      {{#if is_critical_path}}
      - **Recommend:** Run `/ecc-e2e` ‚Äî E2E gap on critical path ({{critical_path_reason}})
      {{/if}}
      {{#if NOT is_critical_path}}
      - Consider running `/ecc-e2e` for E2E coverage of new UI changes
      {{/if}}
      {{/if}}
      {{/if}}
      {{#if new_status != "done"}}
      - Address remaining issues
      - Re-run `/ecc-code-review` after fixes
      {{/if}}
    </output>
  </step>

</workflow>
